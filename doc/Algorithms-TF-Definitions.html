<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.TF.Definitions</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-TF-Definitions.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/TF/Definitions.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.TF.Definitions</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Qram abstraction
</a></li><li><a href="#g:2">Types for the Triangle Finding Algorithm
</a></li><li><a href="#g:3">TF integers
</a><ul><li><a href="#g:4">Types
</a></li><li><a href="#g:5">Operations for IntTF
</a></li><li><a href="#g:6">Operations for QIntTF
</a></li><li><a href="#g:7">Auxiliary functions
</a></li></ul></li><li><a href="#g:8">Miscellaneous circuit-building functions
</a></li><li><a href="#g:9">Arithmetic functions
</a></li><li><a href="#g:10">IntMaps as QData
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides global definitions for the Triangle Finding Algorithm. 
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Qram">Qram</a>  = <a href="#v:Qram">Qram</a> {<ul class="subs"><li><a href="#v:qram_fetch">qram_fetch</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</li><li><a href="#v:qram_store">qram_store</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</li><li><a href="#v:qram_swap">qram_swap</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:CNode">CNode</a> = &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:QNode">QNode</a> = &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:QWTFP_spec">QWTFP_spec</a> = (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-TF-Definitions.html#t:Qram">Qram</a>)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:XIntTF">XIntTF</a> x = <a href="#v:XIntTF">XIntTF</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</li><li class="src short"><span class="keyword">type</span> <a href="#t:QIntTF">QIntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CIntTF">CIntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IntTF">IntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:integer_of_inttf">integer_of_inttf</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:inttf_of_integer">inttf_of_integer</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></li><li class="src short"><a href="#v:inttf">inttf</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></li><li class="src short"><a href="#v:inttf_length">inttf_length</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:inttf_set_length">inttf_set_length</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></li><li class="src short"><a href="#v:inttf_promote">inttf_promote</a> ::  <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></li><li class="src short"><a href="#v:show_inttf">show_inttf</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:qulist_of_qinttf_lh">qulist_of_qinttf_lh</a> :: <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:qinttf_of_qulist_lh">qinttf_of_qulist_lh</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></li><li class="src short"><a href="#v:qinttf_shape">qinttf_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></li><li class="src short"><a href="#v:xinttf_of_xint">xinttf_of_xint</a> ::  <a href="QuipperLib-Arith.html#t:XInt">XInt</a> x -&gt; <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x</li><li class="src short"><a href="#v:xint_of_xinttf">xint_of_xinttf</a> ::  <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x -&gt; <a href="QuipperLib-Arith.html#t:XInt">XInt</a> x</li><li class="src short"><a href="#v:xint_with_promote">xint_with_promote</a> ::  <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> y -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="QuipperLib-Arith.html#t:IntM">IntM</a></li><li class="src short"><a href="#v:phaseFlipIf">phaseFlipIf</a> :: <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> ctrl =&gt; ctrl -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:phaseFlipUnless">phaseFlipUnless</a> :: <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> ctrl =&gt; ctrl -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qor">qor</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; &#91;(<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:increment">increment</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></li><li class="src short"><a href="#v:decrement">decrement</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></li><li class="src short"><a href="#v:increment_big">increment_big</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:decrement_big">decrement_big</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:increment_little">increment_little</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:decrement_little">decrement_little</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:choose">choose</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:addKeys">addKeys</a> ::  IntMap a -&gt; IntMap (Key, a)</li><li class="src short"><a href="#v:mapWithKeyM">mapWithKeyM</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (Key -&gt; a -&gt; m b) -&gt; IntMap a -&gt; m (IntMap b)</li><li class="src short"><a href="#v:mapWithKeyM_">mapWithKeyM_</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (Key -&gt; a -&gt; m b) -&gt; IntMap a -&gt; m ()</li><li class="src short"><a href="#v:intMap_replicate">intMap_replicate</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; a -&gt; IntMap a</li><li class="src short"><a href="#v:-33-">(!)</a> ::  IntMap a -&gt; Key -&gt; a</li></ul></div><div id="interface"><h1 id="g:1">Qram abstraction
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Qram" class="def">Qram</a>  <a href="src/Algorithms/TF/Definitions.html#line-38" class="link">Source</a></p><div class="doc"><p>A data structure to hold a Qram implementation. This provides
 operations for fetching and storing quantum data from a quantum
 array, addressed by a quantum integer. One implementation is given
 by algorithms <code>a8_FetchT</code>, <code>a9_StoreT</code> and <code>a10_FetchStoreT</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Qram" class="def">Qram</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:qram_fetch" class="def">qram_fetch</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:qram_store" class="def">qram_store</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:qram_swap" class="def">qram_swap</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; IntMap qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, IntMap qa, qa)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><h1 id="g:2">Types for the Triangle Finding Algorithm
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CNode" class="def">CNode</a> = &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-50" class="link">Source</a></p><div class="doc"><p>A node of the graph (classical circuit type). 
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QNode" class="def">QNode</a> = &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-53" class="link">Source</a></p><div class="doc"><p>A node of the graph (quantum circuit type). 
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QWTFP_spec" class="def">QWTFP_spec</a> = (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-TF-Definitions.html#t:Qram">Qram</a>)<a href="src/Algorithms/TF/Definitions.html#line-67" class="link">Source</a></p><div class="doc"><p>The type of problem specifications for the Triangle Finding Problem. A problem 
 specification consists of: 
</p><ul><li> an integer <em>n</em> which determines the number <em>N=</em><em>2</em><sup><em>n</em></sup> of nodes of the graph,
</li><li> an integer <em>r</em> which determines the size <em>R=</em><em>2</em><sup><em>r</em></sup> of tuples in the Hamming
 graph, 
</li><li> a function <em>edge_oracle</em> which inputs two graph nodes and a qubit and flips the qubit 
 if the nodes are connected by an edge and
</li><li> additional options, for selecting, e.g., which qRAM implementation should be used.
</li></ul></div></div><h1 id="g:3">TF integers
</h1><h2 id="g:4">Types
</h2><div class="doc"><p>We define a <code><a href="Quipper-QData.html#t:QData">QData</a></code> family of integer datatypes (<code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code>,
 <code><a href="Algorithms-TF-Definitions.html#t:CIntTF">CIntTF</a></code>, <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code>). These are similar to (<code><a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></code>, <code><a href="QuipperLib-Arith.html#t:CInt">CInt</a></code>, <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code>),
 except that the integers are considered to be mod 2<sup><em>m</em></sup>-1 instead
 of 2<sup><em>m</em></sup>.
</p><p>In general, functions on these types should be able to handle both 00&#8230;00 and 11&#8230;11, 
 and should treat them equally, essentially regarding <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code>, <code><a href="Algorithms-TF-Definitions.html#t:CIntTF">CIntTF</a></code>, and the 
 computational basis of <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code> as formal quotients.
 Some operations are not perfect. One should keep in mind, for example, that specifying 
 a control on a <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code> of the form <code><em>q</em> .==. 0</code> will compare the bitwise representation 
 to 0, and not the logical quotient.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:XIntTF" class="def">XIntTF</a> x <a href="src/Algorithms/TF/Definitions.html#line-91" class="link">Source</a></p><div class="doc"><p>All three types <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code>, <code><a href="Algorithms-TF-Definitions.html#t:CIntTF">CIntTF</a></code>, and <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> are special cases
 of a more general type <code><a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></code> <em>x</em>, parameterized by a type <em>x</em> of
 bits. It is an abstract type, and details of its implementation is
 not exposed to user-level code.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:XIntTF" class="def">XIntTF</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:XIntTF" class="caption collapser" onclick="toggleSection('i:XIntTF')">Instances</p><div id="section.i:XIntTF" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> x =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x) <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QIntTF" class="def">QIntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/Algorithms/TF/Definitions.html#line-96" class="link">Source</a></p><div class="doc"><p>The type of fixed-length <em>m</em>-qubit quantum integers, regarded
 modulo 2<sup><em>m</em></sup>-1.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CIntTF" class="def">CIntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/TF/Definitions.html#line-100" class="link">Source</a></p><div class="doc"><p>The type of fixed-length <em>m</em>-bit classical integers, regarded
 modulo 2<sup><em>m</em></sup>-1.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IntTF" class="def">IntTF</a> = <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/TF/Definitions.html#line-105" class="link">Source</a></p><div class="doc"><p>The type of fixed-length <em>m</em>-bit integer parameters, regarded
 modulo 2<sup><em>m</em></sup>-1. A value of type <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> may have indeterminate
 length, similarly to <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code>.
</p></div></div><h2 id="g:5">Operations for IntTF
</h2><div class="top"><p class="src"><a name="v:integer_of_inttf" class="def">integer_of_inttf</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a><a href="src/Algorithms/TF/Definitions.html#line-113" class="link">Source</a></p><div class="doc"><p>Convert an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> of length <em>m</em> to an <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></code> in the range {0,
 &#8230;, 2<sup><em>m</em></sup>-2}. If the <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> has indeterminate length, return
 the original <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:inttf_of_integer" class="def">inttf_of_integer</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a><a href="src/Algorithms/TF/Definitions.html#line-120" class="link">Source</a></p><div class="doc"><p>Convert an <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></code> to an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> of indeterminate length.
</p></div></div><div class="top"><p class="src"><a name="v:inttf" class="def">inttf</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a><a href="src/Algorithms/TF/Definitions.html#line-124" class="link">Source</a></p><div class="doc"><p>Convert an <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></code> to an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> of length <em>m</em>.
</p></div></div><div class="top"><p class="src"><a name="v:inttf_length" class="def">inttf_length</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/TF/Definitions.html#line-130" class="link">Source</a></p><div class="doc"><p>Return the length of an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code>, or <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#v:Nothing">Nothing</a></code> if indeterminate.
</p></div></div><div class="top"><p class="src"><a name="v:inttf_set_length" class="def">inttf_set_length</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a><a href="src/Algorithms/TF/Definitions.html#line-152" class="link">Source</a></p><div class="doc"><p>Set the length of an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> to <em>m</em> &#8805; 0. This operation is only
 legal if the input (a) has indeterminate length or (b) has
 determinate length already equal to <em>m</em>. In particular, it cannot
 be used to change the length from anything other than from
 indeterminate to determinate. 
</p><p>If both arguments already have determinate lengths, and they do not
 coincide, throw an error. The <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></code> argument is used as an error
 message in that case.
</p></div></div><div class="top"><p class="src"><a name="v:inttf_promote" class="def">inttf_promote</a> ::  <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a><a href="src/Algorithms/TF/Definitions.html#line-171" class="link">Source</a></p><div class="doc"><p>Try to set the length of an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> to that of another <code><a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></code>
 value (which could be a <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code>, a <code><a href="Algorithms-TF-Definitions.html#t:CIntTF">CIntTF</a></code>, or another <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code>). This
 will fail with an error if both numbers already have determinate
 lengths that don't coincide. In this case, the string argument is
 used as an error message. The promotion is done modulo 2<sup><em>m</em></sup>-1.
</p></div></div><div class="top"><p class="src"><a name="v:show_inttf" class="def">show_inttf</a> :: <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a><a href="src/Algorithms/TF/Definitions.html#line-179" class="link">Source</a></p><div class="doc"><p>Convert an <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> to human readable form. We show the bit value,
 i.e., 0 and 2<sup><em>m</em></sup>-1 are shown as different values. 
</p></div></div><h2 id="g:6">Operations for QIntTF
</h2><div class="top"><p class="src"><a name="v:qulist_of_qinttf_lh" class="def">qulist_of_qinttf_lh</a> :: <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-195" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code> to a list of qubits. The conversion is
 little-headian, i.e., the head of the list holds the least
 significant digit.
</p></div></div><div class="top"><p class="src"><a name="v:qinttf_of_qulist_lh" class="def">qinttf_of_qulist_lh</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a><a href="src/Algorithms/TF/Definitions.html#line-201" class="link">Source</a></p><div class="doc"><p>Convert a list of qubits to a <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code>. The conversion is
 little-headian, i.e., the head of the list holds the least
 significant digit.
</p></div></div><div class="top"><p class="src"><a name="v:qinttf_shape" class="def">qinttf_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a><a href="src/Algorithms/TF/Definitions.html#line-207" class="link">Source</a></p><div class="doc"><p>Return a piece of shape data to represent an <em>m</em>-qubit
 <code><a href="Algorithms-TF-Definitions.html#t:QIntTF">QIntTF</a></code>. Please note that the data can only be used as shape; it
 will be undefined at the leaves.
</p></div></div><h2 id="g:7">Auxiliary functions
</h2><div class="top"><p class="src"><a name="v:xinttf_of_xint" class="def">xinttf_of_xint</a> ::  <a href="QuipperLib-Arith.html#t:XInt">XInt</a> x -&gt; <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x<a href="src/Algorithms/TF/Definitions.html#line-216" class="link">Source</a></p><div class="doc"><p>The low-level isomorphism from <code><a href="QuipperLib-Arith.html#t:XInt">XInt</a></code> <em>x</em> to <code><a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></code> <em>x</em>. Note
 that &quot;isomorphism&quot; is between the underlying raw types, and does not
 respect the arithmetic operations.
</p></div></div><div class="top"><p class="src"><a name="v:xint_of_xinttf" class="def">xint_of_xinttf</a> ::  <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> x -&gt; <a href="QuipperLib-Arith.html#t:XInt">XInt</a> x<a href="src/Algorithms/TF/Definitions.html#line-222" class="link">Source</a></p><div class="doc"><p>The low-level isomorphism from <code><a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></code> <em>x</em> to <code><a href="QuipperLib-Arith.html#t:XInt">XInt</a></code> <em>x</em>.  Note
 that &quot;isomorphism&quot; is between the underlying raw types, and does not
 respect the arithmetic operations.
</p></div></div><div class="top"><p class="src"><a name="v:xint_with_promote" class="def">xint_with_promote</a> ::  <a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a> y -&gt; <a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a> -&gt; <a href="QuipperLib-Arith.html#t:IntM">IntM</a><a href="src/Algorithms/TF/Definitions.html#line-227" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Algorithms-TF-Definitions.html#v:xint_of_xinttf">xint_of_xinttf</a></code>, but first try to promote the length of the
 <code><a href="Algorithms-TF-Definitions.html#t:IntTF">IntTF</a></code> to that of the given <code><a href="Algorithms-TF-Definitions.html#t:XIntTF">XIntTF</a></code>.
</p></div></div><h1 id="g:8">Miscellaneous circuit-building functions
</h1><div class="top"><p class="src"><a name="v:phaseFlipIf" class="def">phaseFlipIf</a> :: <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> ctrl =&gt; ctrl -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/TF/Definitions.html#line-258" class="link">Source</a></p><div class="doc"><p>Controlled phase flip of -1.
</p></div></div><div class="top"><p class="src"><a name="v:phaseFlipUnless" class="def">phaseFlipUnless</a> :: <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> ctrl =&gt; ctrl -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/TF/Definitions.html#line-266" class="link">Source</a></p><div class="doc"><p>Variant of <code>phaseFlip</code> that performs a phase flip <em>unless</em> all
 controls are in the given state.
</p></div></div><div class="top"><p class="src"><a name="v:qor" class="def">qor</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; &#91;(<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/Algorithms/TF/Definitions.html#line-273" class="link">Source</a></p><div class="doc"><p><code>qor q c</code>: Applies &quot;not&quot; to <em>q</em>, if <em>any</em> of the control qubits
 in <em>c</em> is in specified state.
</p></div></div><h1 id="g:9">Arithmetic functions
</h1><div class="top"><p class="src"><a name="v:increment" class="def">increment</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a><a href="src/Algorithms/TF/Definitions.html#line-283" class="link">Source</a></p><div class="doc"><p>Increment a standard <code><a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></code> (i.e. big-endian, mod 2<sup>&#8467;</sup>).
</p></div></div><div class="top"><p class="src"><a name="v:decrement" class="def">decrement</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a><a href="src/Algorithms/TF/Definitions.html#line-291" class="link">Source</a></p><div class="doc"><p>Decrement a standard <code><a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></code> (i.e. big-endian, mod 2<sup>&#8467;</sup>).
</p></div></div><div class="top"><p class="src"><a name="v:increment_big" class="def">increment_big</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-299" class="link">Source</a></p><div class="doc"><p>Increment a bit-string, considered as a big-endian integer mod 2<sup>&#8467;</sup>.
</p></div></div><div class="top"><p class="src"><a name="v:decrement_big" class="def">decrement_big</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-307" class="link">Source</a></p><div class="doc"><p>Decrement a bit-string, considered as a big-endian integer mod 2<sup>&#8467;</sup>.
</p></div></div><div class="top"><p class="src"><a name="v:increment_little" class="def">increment_little</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-315" class="link">Source</a></p><div class="doc"><p>Increment a bit-string, considered as a little-endian integer mod 2<sup>&#8467;</sup>.
</p></div></div><div class="top"><p class="src"><a name="v:decrement_little" class="def">decrement_little</a> :: &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/Algorithms/TF/Definitions.html#line-323" class="link">Source</a></p><div class="doc"><p>Decrement a bit-string, considered as a little-endian integer mod 2<sup>&#8467;</sup>.
</p></div></div><div class="top"><p class="src"><a name="v:choose" class="def">choose</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a -&gt; a<a href="src/Algorithms/TF/Definitions.html#line-331" class="link">Source</a></p><div class="doc"><p>The standard &#8220;combinations&#8221; function &#8220;<em>n</em> choose <em>k</em>&#8221;.
</p></div></div><h1 id="g:10">IntMaps as QData
</h1><div class="top"><p class="src"><a name="v:addKeys" class="def">addKeys</a> ::  IntMap a -&gt; IntMap (Key, a)<a href="src/Algorithms/TF/Definitions.html#line-340" class="link">Source</a></p><div class="doc"><p>Replace an <code>IntMap</code> <em>f</em> with the <code>IntMap</code> mapping each key <em>k</em> to (<em>k</em>,<em>f(k)</em>).  An auxiliary function for defining <code><a href="Algorithms-TF-Definitions.html#v:mapWithKeyM">mapWithKeyM</a></code>, etc.
</p></div></div><div class="top"><p class="src"><a name="v:mapWithKeyM" class="def">mapWithKeyM</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (Key -&gt; a -&gt; m b) -&gt; IntMap a -&gt; m (IntMap b)<a href="src/Algorithms/TF/Definitions.html#line-344" class="link">Source</a></p><div class="doc"><p>Analogous to <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Traversable.html#v:mapM">mapM</a></code>, but allows the function to use the key.  Particularly useful for mapping in parallel over two (or more) <code>IntMap</code>s assumed to have the same domain. 
</p></div></div><div class="top"><p class="src"><a name="v:mapWithKeyM_" class="def">mapWithKeyM_</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (Key -&gt; a -&gt; m b) -&gt; IntMap a -&gt; m ()<a href="src/Algorithms/TF/Definitions.html#line-348" class="link">Source</a></p><div class="doc"><p>Analogous to <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html#v:mapM_">mapM_</a></code>, but allows the function to use the key.
</p></div></div><div class="top"><p class="src"><a name="v:intMap_replicate" class="def">intMap_replicate</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; a -&gt; IntMap a<a href="src/Algorithms/TF/Definitions.html#line-352" class="link">Source</a></p><div class="doc"><p>Analogous to <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:replicate">replicate</a></code> on lists.
</p></div></div><div class="top"><p class="src"><a name="v:-33-" class="def">(!)</a> ::  IntMap a -&gt; Key -&gt; a<a href="src/Algorithms/TF/Definitions.html#line-358" class="link">Source</a></p><div class="doc"><p>Convenient syntax for accessing elements of an <code>IntMap</code>.  Left associative, and binds very strongly, like '(!!)'.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
