<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.ClassicalOptim.AlgExp</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-ClassicalOptim-AlgExp.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/ClassicalOptim/AlgExp.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.ClassicalOptim.AlgExp</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary functions
</a></li><li><a href="#g:2">Expressions
</a></li><li><a href="#g:3">Properties of expressions
</a><ul><li><a href="#g:4">Truth tables
</a></li><li><a href="#g:5">Quick-checking
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains an efficient representation of algebraic
 boolean formulas.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:mapOfSet">mapOfSet</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; Set a -&gt; Map a <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:setOfMap">setOfMap</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; Map a <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Set a</li><li class="src short"><a href="#v:split_even">split_even</a> ::  &#91;a&#93; -&gt; (&#91;a&#93;, &#91;a&#93;)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Exp">Exp</a> = Set IntSet</li><li class="src short"><a href="#v:listOfExp">listOfExp</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;&#93;</li><li class="src short"><a href="#v:expOfList">expOfList</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_and">exp_and</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_xor">exp_xor</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_false">exp_false</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_true">exp_true</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_not">exp_not</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:exp_var">exp_var</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:vars_of_exp">vars_of_exp</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;</li><li class="src short"><a href="#v:exp_eval">exp_eval</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; Map <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:valuations_of_vars">valuations_of_vars</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; &#91;Map <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:truth_table_of_exp">truth_table_of_exp</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:exp_of_truth_table">exp_of_truth_table</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:twoExp">twoExp</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:genBoolList">genBoolList</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; Gen &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:test_args">test_args</a> :: Args</li><li class="src short"><a href="#v:test_truth1">test_truth1</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:genIntList">genIntList</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Gen &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;</li><li class="src short"><a href="#v:genExp">genExp</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; Gen <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:test_truth2">test_truth2</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Auxiliary functions
</h1><div class="top"><p class="src"><a name="v:mapOfSet" class="def">mapOfSet</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; Set a -&gt; Map a <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-25" class="link">Source</a></p><div class="doc"><p>Build the characteristic function of a set.
</p></div></div><div class="top"><p class="src"><a name="v:setOfMap" class="def">setOfMap</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; Map a <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Set a<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-29" class="link">Source</a></p><div class="doc"><p>Get the set of elements whose images are odd.
</p></div></div><div class="top"><p class="src"><a name="v:split_even" class="def">split_even</a> ::  &#91;a&#93; -&gt; (&#91;a&#93;, &#91;a&#93;)<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-35" class="link">Source</a></p><div class="doc"><p>Split a list in the middle.
</p></div></div><h1 id="g:2">Expressions
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Exp" class="def">Exp</a> = Set IntSet<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-56" class="link">Source</a></p><div class="doc"><p>The type of algebraic boolean expressions. 
</p><p>We represent boolean expressions using &quot;and&quot; and &quot;xor&quot; as the
 primitive connectives. Equivalently, we can regard booleans as the
 elements of the two-element field <em>F</em><sub>2</sub>, with operations &quot;*&quot;
 (times) and &quot;+&quot; (plus). 
</p><p>An algebraic expression
      <code>x1*x2*x3 + y1*y2*y3 + z1*z2</code>
 is encoded as
      <code>{{x1,x2,x3},{y1,y2,y3},{z1,z2}}</code>.
</p><p>In particular,
     <code>{}   == False == 0</code> and 
     <code>{{}} == True  == 1</code>.
</p></div></div><div class="top"><p class="src"><a name="v:listOfExp" class="def">listOfExp</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-64" class="link">Source</a></p><div class="doc"><p>Turn an <code>Exp</code> into a list of lists.
</p></div></div><div class="top"><p class="src"><a name="v:expOfList" class="def">expOfList</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-68" class="link">Source</a></p><div class="doc"><p>Turn a list of lists into an <code>Exp</code>.
</p></div></div><div class="top"><p class="src"><a name="v:exp_and" class="def">exp_and</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-72" class="link">Source</a></p><div class="doc"><p>The conjunction of two expression.
</p></div></div><div class="top"><p class="src"><a name="v:exp_xor" class="def">exp_xor</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-81" class="link">Source</a></p><div class="doc"><p>The xor of two expressions.
</p></div></div><div class="top"><p class="src"><a name="v:exp_false" class="def">exp_false</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-85" class="link">Source</a></p><div class="doc"><p>The expression &quot;False&quot;.
</p></div></div><div class="top"><p class="src"><a name="v:exp_true" class="def">exp_true</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-89" class="link">Source</a></p><div class="doc"><p>The expression &quot;True&quot;.
</p></div></div><div class="top"><p class="src"><a name="v:exp_not" class="def">exp_not</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-93" class="link">Source</a></p><div class="doc"><p>The negation of an expression.
</p></div></div><div class="top"><p class="src"><a name="v:exp_var" class="def">exp_var</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-97" class="link">Source</a></p><div class="doc"><p>The expression <em>x</em><sub><em>n</em></sub>.
</p></div></div><h1 id="g:3">Properties of expressions
</h1><div class="doc"><p>The important property of expressions is that two formulas have
 the same truth table iff they are syntactically equal. This makes
 the equality test of wires theoretically straightforward.
</p><p>The following automated tests check this property, using the
 <a href="Test-QuickCheck.html">Test.QuickCheck</a> library.
</p></div><h2 id="g:4">Truth tables
</h2><div class="doc"><p>A <em>valuation</em> on a set of variables is a map from variables to
 booleans. This can be thought of as a row in a truth table. A
 <em>truth table</em> is a map from valuations to booleans, but we just
 represent this as a list of booleans, listed in lexicographically
 increasing order of valuations.
</p></div><div class="top"><p class="src"><a name="v:vars_of_exp" class="def">vars_of_exp</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-120" class="link">Source</a></p><div class="doc"><p>Get the variables used in an expression.
</p></div></div><div class="top"><p class="src"><a name="v:exp_eval" class="def">exp_eval</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; Map <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-126" class="link">Source</a></p><div class="doc"><p>Evaluate the expression with respect to the given valuation. A
 <em>valuation</em> is a map from variables to booleans, i.e., a row in a
 truth table.
</p></div></div><div class="top"><p class="src"><a name="v:valuations_of_vars" class="def">valuations_of_vars</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; &#91;Map <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-131" class="link">Source</a></p><div class="doc"><p>Construct the list of all 2<sup><em>n</em></sup> valuations for a given
 list of <em>n</em> variables.
</p></div></div><div class="top"><p class="src"><a name="v:truth_table_of_exp" class="def">truth_table_of_exp</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-149" class="link">Source</a></p><div class="doc"><p>Build the truth table for the given expression, on the given list
 of variables. The truth table is returned as a list of booleans in
 lexicographic order of valuations. For example, if
</p><pre>  1 2 | exp
  F F | f1
  F T | f2
  T F | f3
  T T | f4
</pre><p>then the output of the function is <code>&#91;f1,f2,f3,f4&#93;</code>.
</p></div></div><div class="top"><p class="src"><a name="v:exp_of_truth_table" class="def">exp_of_truth_table</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-154" class="link">Source</a></p><div class="doc"><p>Return an expression realizing the given truth table. Uses
 variables starting with the given number.
</p></div></div><h2 id="g:5">Quick-checking
</h2><div class="top"><p class="src"><a name="v:twoExp" class="def">twoExp</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-168" class="link">Source</a></p><div class="doc"><p>Compute 2<sup><em>n</em></sup>.
</p></div></div><div class="top"><p class="src"><a name="v:genBoolList" class="def">genBoolList</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; Gen &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-174" class="link">Source</a></p><div class="doc"><p>Generate a list of <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:test_args" class="def">test_args</a> :: Args<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-178" class="link">Source</a></p><div class="doc"><p>Arguments for QuickCheck.
</p></div></div><div class="top"><p class="src"><a name="v:test_truth1" class="def">test_truth1</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> ()<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-184" class="link">Source</a></p><div class="doc"><p>First test: truth table to expression to truth table is the identity.
</p></div></div><div class="top"><p class="src"><a name="v:genIntList" class="def">genIntList</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Gen &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93;<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-191" class="link">Source</a></p><div class="doc"><p>Generate a random list of <code>Int</code>s.
</p></div></div><div class="top"><p class="src"><a name="v:genExp" class="def">genExp</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>&#93; -&gt; Gen <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-197" class="link">Source</a></p><div class="doc"><p>Generate a random expression out of the given variables.
</p></div></div><div class="top"><p class="src"><a name="v:test_truth2" class="def">test_truth2</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> ()<a href="src/QuipperLib/ClassicalOptim/AlgExp.html#line-205" class="link">Source</a></p><div class="doc"><p>Second test: expression to truth table to expression is the
 identity.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
