<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Synthesis</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Synthesis.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Synthesis.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Synthesis</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Precision
</a></li><li><a href="#g:2">Phase
</a></li><li><a href="#g:3">Auxiliary functions
</a></li><li><a href="#g:4">Single-qubit exact synthesis
</a></li><li><a href="#g:5">Multi-qubit exact synthesis
</a></li><li><a href="#g:6">Single-qubit approximate synthesis
</a><ul><li><a href="#g:7"><em>z</em>-Rotations
</a></li><li><a href="#g:8">Global phase gates
</a></li><li><a href="#g:9"><em>U</em>(2) from Euler angles
</a></li><li><a href="#g:10"><em>U</em>(2) from matrix
</a></li><li><a href="#g:11">Controlled gates
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A Quipper library for synthesizing Clifford+<em>T</em> circuits directly
 from a matrix description or Euler angle description of a unitary
 operator. This library provides both exact and approximate
 synthesis.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Precision">Precision</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></li><li class="src short"><a href="#v:bits">bits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a></li><li class="src short"><a href="#v:digits">digits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:KeepPhase">KeepPhase</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:apply_gate_at">apply_gate_at</a> :: Gate -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_gates_at">apply_gates_at</a> :: &#91;Gate&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_gates2_at">apply_gates2_at</a> :: &#91;Gate&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:twolevel">twolevel</a> :: Index -&gt; Index -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; (<a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_T_power_at">gate_T_power_at</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevel_at">apply_twolevel_at</a> :: TwoLevel -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevels_at">apply_twolevels_at</a> :: &#91;TwoLevel&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevel_alt_at">apply_twolevel_alt_at</a> :: TwoLevelAlt -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevels_alt_at">apply_twolevels_alt_at</a> :: &#91;TwoLevelAlt&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exact_synthesis1">exact_synthesis1</a> :: ToGates a =&gt; a -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:exact_synthesis">exact_synthesis</a> :: (ToQOmega a, Nat n) =&gt; Matrix n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:exact_synthesis_alt">exact_synthesis_alt</a> :: (ToQOmega a, Nat n) =&gt; Matrix n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:approximate_synthesis_zrot">approximate_synthesis_zrot</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_phase">approximate_synthesis_phase</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:approximate_synthesis_euler">approximate_synthesis_euler</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; (SymReal, SymReal, SymReal, SymReal) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_u2">approximate_synthesis_u2</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; U2 (Cplx SymReal) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_zrot_ctrl">approximate_synthesis_zrot_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_phase_ctrl">approximate_synthesis_phase_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li></ul></div><div id="interface"><h1 id="g:1">Precision
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Precision" class="def">Precision</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a><a href="src/QuipperLib/Synthesis.html#line-32" class="link">Source</a></p><div class="doc"><p>A type to measure precision. Precision is expressed as a number
 <em>b</em> of bits, i.e., binary digits, so that &#949; = 2<sup>&#8722;<em>b</em></sup>.
</p></div></div><div class="top"><p class="src"><a name="v:bits" class="def">bits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a><a href="src/QuipperLib/Synthesis.html#line-38" class="link">Source</a></p><div class="doc"><p>Binary digits, as a unit of precision. For example, the following
 specifies a precision of 20 binary digits:
</p><pre> prec = 20 * bits
</pre></div></div><div class="top"><p class="src"><a name="v:digits" class="def">digits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a><a href="src/QuipperLib/Synthesis.html#line-45" class="link">Source</a></p><div class="doc"><p>Decimal digits, as a unit of precision. For example, the
 following specifies a precision of 30 decimal digits:
</p><pre> prec = 30 * digits
</pre></div></div><h1 id="g:2">Phase
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:KeepPhase" class="def">KeepPhase</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Synthesis.html#line-53" class="link">Source</a></p><div class="doc"><p>A boolean flag indicating whether to respect global phases
 during circuit synthesis (<code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>) or disregard them (<code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code>).
</p></div></div><h1 id="g:3">Auxiliary functions
</h1><div class="top"><p class="src"><a name="v:apply_gate_at" class="def">apply_gate_at</a> :: Gate -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-60" class="link">Source</a></p><div class="doc"><p>Apply a gate (from the type <code>Gate</code> of Clifford+<em>T</em> operators) to
 the given <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:apply_gates_at" class="def">apply_gates_at</a> :: &#91;Gate&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-84" class="link">Source</a></p><div class="doc"><p>Apply a gate list (from the type <code>Gate</code> of Clifford+<em>T</em>
 operators) to the given <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code>. 
</p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.
</p></div></div><div class="top"><p class="src"><a name="v:apply_gates2_at" class="def">apply_gates2_at</a> :: &#91;Gate&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-90" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:apply_gates_at">apply_gates_at</a></code>, but apply the same list of gates to two
 qubits in parallel.
</p></div></div><div class="top"><p class="src"><a name="v:twolevel" class="def">twolevel</a> :: Index -&gt; Index -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; (<a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-107" class="link">Source</a></p><div class="doc"><p>Input two indices <em>i</em> and <em>j</em>, a list of qubits <em>qlist</em>, and an
 imperative-style single-qubit gate <em>U</em>. Apply the two-level
 operator <em>U</em><sub><em>i</em>,<em>j</em></sub> to <em>qlist</em>. Intended usage:
</p><pre> twolevel i j qlist gate_U_at
</pre><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.
</p><p>This function implements an improved version of Gray codes.
</p></div></div><div class="top"><p class="src"><a name="v:gate_T_power_at" class="def">gate_T_power_at</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-139" class="link">Source</a></p><div class="doc"><p>Apply a <em>T</em><sup><em>m</em></sup> gate. This gate is decomposed into <em>Z</em>, <em>S</em>,
 <em>S</em><sup>&#8224;</sup>, <em>T</em>, and <em>T</em><sup>&#8224;</sup> gates.
</p></div></div><div class="top"><p class="src"><a name="v:apply_twolevel_at" class="def">apply_twolevel_at</a> :: TwoLevel -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-163" class="link">Source</a></p><div class="doc"><p>Apply a <code>TwoLevel</code> gate to the given list of qubits. 
 The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.
</p></div></div><div class="top"><p class="src"><a name="v:apply_twolevels_at" class="def">apply_twolevels_at</a> :: &#91;TwoLevel&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-198" class="link">Source</a></p><div class="doc"><p>Apply a list of <code>TwoLevel</code> gates to the given list of
 qubits. 
</p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.
</p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.
</p></div></div><div class="top"><p class="src"><a name="v:apply_twolevel_alt_at" class="def">apply_twolevel_alt_at</a> :: TwoLevelAlt -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-204" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:apply_twolevel_at">apply_twolevel_at</a></code>, but use the alternate generators for
 two-level gates.
</p></div></div><div class="top"><p class="src"><a name="v:apply_twolevels_alt_at" class="def">apply_twolevels_alt_at</a> :: &#91;TwoLevelAlt&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-252" class="link">Source</a></p><div class="doc"><p>Apply a list of <code>TwoLevelAlt</code> gates to the given list of
 qubits. 
</p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.
</p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.
</p></div></div><h1 id="g:4">Single-qubit exact synthesis
</h1><div class="top"><p class="src"><a name="v:exact_synthesis1" class="def">exact_synthesis1</a> :: ToGates a =&gt; a -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-274" class="link">Source</a></p><div class="doc"><p>Decompose the given operator exactly into a single-qubit
 Clifford+<em>T</em> circuit. The operator must be given in one of the
 available exact formats, i.e., any instance of the <code>ToGates</code> class.
 Typical instances are:
</p><ul><li> <code>U2</code> <code>DRComplex</code>: a 2&#215;2 unitary operator with entries from the
 ring &#8484;&#91;1/&#8730;2, <em>i</em>&#93;;
</li><li> <code>U2</code> <code>DOmega</code>: a 2&#215;2 unitary operator with entries from the ring
 <b>D</b>&#91;&#969;&#93;;
</li><li> <code>SO3</code> <code>DRootTwo</code>: a 3&#215;3 Bloch sphere operator with entries from the
 ring &#8484;&#91;1/&#8730;2&#93;. In this last case, the operator will be synthesized
 up to an unspecified global phase.
</li></ul></div></div><h1 id="g:5">Multi-qubit exact synthesis
</h1><div class="top"><p class="src"><a name="v:exact_synthesis" class="def">exact_synthesis</a> :: (ToQOmega a, Nat n) =&gt; Matrix n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/QuipperLib/Synthesis.html#line-300" class="link">Source</a></p><div class="doc"><p>Decompose the given operator exactly into a Clifford+<em>T</em> circuit.
 The operator must be given as an <em>n</em>&#215;<em>n</em>-matrix with coefficients
 in a ring that is an instance of the <code>ToQRComplex</code> class. Typical
 examples of such rings are <code>DRComplex</code>, <code>DOmega</code>, and <code>QRComplex</code>.
</p><p>If this function is applied to a list of <em>m</em> qubits, then we must
 have <em>n</em> &#8804; 2<sup><em>m</em></sup>.
</p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.
</p><p>The generated circuit contains no ancillas, but may contain
 multi-controlled gates whose decomposition into Clifford+<em>T</em>
 generators requires ancillas.
</p></div></div><div class="top"><p class="src"><a name="v:exact_synthesis_alt" class="def">exact_synthesis_alt</a> :: (ToQOmega a, Nat n) =&gt; Matrix n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;<a href="src/QuipperLib/Synthesis.html#line-314" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:exact_synthesis">exact_synthesis</a></code>, but use the alternate algorithm from
 Section 6 of Giles-Selinger. This means all but at most one of the
 generated multi-controlled gates have determinant 1, which means
 they can be further decomposed without ancillas.
</p></div></div><h1 id="g:6">Single-qubit approximate synthesis
</h1><h2 id="g:7"><em>z</em>-Rotations
</h2><div class="top"><p class="src"><a name="v:approximate_synthesis_zrot" class="def">approximate_synthesis_zrot</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-342" class="link">Source</a></p><div class="doc"><p>Decompose an <em>R</em><sub><em>z</em></sub>(&#952;) = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup> gate into a
 single-qubit Clifford+<em>T</em> circuit up to the given precision. 
</p><p><img src="images/Rz.png">
</p><p>The parameters are:
</p><ul><li> a precision <em>b</em> &#8805; 0;
</li><li> an angle &#952;, given as a <code>SymReal</code> value;
</li><li> a source of randomness <em>g</em>.
</li></ul></div></div><h2 id="g:8">Global phase gates
</h2><div class="top"><p class="src"><a name="v:approximate_synthesis_phase" class="def">approximate_synthesis_phase</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Synthesis.html#line-372" class="link">Source</a></p><div class="doc"><p>Construct a Clifford+<em>T</em> circuit (with no inputs and outputs)
 that approximates a scalar global phase gate <i>e</i><sup><em>i</em>&#952;</sup> up to the
 given precision. The parameters are:
</p><ul><li> a flag <em>keepphase</em> to indicate whether global phase should be
 respected. (Note that if this is set to <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code>, then this function
 is just a no-op);
</li><li> a precision <em>b</em> &#8805; 0;
</li><li> an angle &#952;, given as a <code>SymReal</code> value;
</li><li> a source of randomness <em>g</em>.
</li></ul><p>We use the following decomposition:
</p><p><img src="images/phase.png">
</p></div></div><h2 id="g:9"><em>U</em>(2) from Euler angles
</h2><div class="top"><p class="src"><a name="v:approximate_synthesis_euler" class="def">approximate_synthesis_euler</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; (SymReal, SymReal, SymReal, SymReal) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-404" class="link">Source</a></p><div class="doc"><p>Decompose the operator
</p><ul><li> <em>U</em> = <i>e</i><sup><em>i</em>&#945;</sup> R<sub><em>z</em></sub>(&#946;) R<sub><em>x</em></sub>(&#947;) R<sub><em>z</em></sub>(&#948;)
</li></ul><p>into the Clifford+<em>T</em> gate base, up to the given precision.
 The parameters are:
</p><ul><li> a flag <em>keepphase</em> to indicate whether global phase should be
   respected. If this is <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code>, the angle &#945; is disregarded;
</li><li> a precision <em>b</em> &#8805; 0;
</li><li> a tuple of Euler angles (&#945;, &#946;, &#947;, &#948;), given as <code>SymReal</code> values;
</li><li> a source of randomness <em>g</em>.
</li></ul></div></div><h2 id="g:10"><em>U</em>(2) from matrix
</h2><div class="top"><p class="src"><a name="v:approximate_synthesis_u2" class="def">approximate_synthesis_u2</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; U2 (Cplx SymReal) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-436" class="link">Source</a></p><div class="doc"><p>Decompose a single-qubit unitary gate <em>U</em> into the Clifford+<em>T</em>
 gate base, up to the given precision, provided that det <em>U</em> = 1.
 The parameters are:
</p><ul><li> a flag <em>keepphase</em> to indicate whether global phase should be
 respected;
</li><li> a precision <em>b</em> &#8805; 0;
</li><li> a 2&#215;2 complex matrix, with entries expressed as <code>Cplx</code> <code>SymReal</code> values;
</li><li> a source of randomness <em>g</em>.
</li></ul></div></div><h2 id="g:11">Controlled gates
</h2><div class="top"><p class="src"><a name="v:approximate_synthesis_zrot_ctrl" class="def">approximate_synthesis_zrot_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-461" class="link">Source</a></p><div class="doc"><p>Decompose a controlled <em>R</em><sub><em>z</em></sub>(&#952;) = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup> gate
 into a single-qubit Clifford+<em>T</em> circuit up to the given
 precision. The parameters are as for <code><a href="QuipperLib-Synthesis.html#v:approximate_synthesis_phase">approximate_synthesis_phase</a></code>.
 The first input is the target qubit, and the second input the
 control.
</p><p>We use the following decomposition. It has lower <em>T</em>-count than the
 alternatives and makes good use of parallelism. Since it uses the
 same rotation twice, only a single run of the synthesis algorithm
 is required.
</p><p><img src="images/controlled-zrot.png">
</p></div></div><div class="top"><p class="src"><a name="v:approximate_synthesis_phase_ctrl" class="def">approximate_synthesis_phase_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; SymReal -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Synthesis.html#line-489" class="link">Source</a></p><div class="doc"><p>Decompose a controlled phase gate
</p><p><img src="images/controlled_phase.png">
</p><p>into the Clifford+<em>T</em> gate base. The parameters are as for
 <code><a href="QuipperLib-Synthesis.html#v:approximate_synthesis_phase">approximate_synthesis_phase</a></code>.
</p><p>We use the following decomposition. It has lower <em>T</em>-count than the
 alternatives and makes good use of parallelism. Since it uses the
 same rotation twice, only a single run of the synthesis algorithm
 is required.
</p><p><img src="images/controlled-phase-decomp.png">
</p><p>If the <code><a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a></code> flag is set, respect global phase; otherwise,
 disregard it.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
